// Code generated by generator, DO NOT EDIT.
package pb

import (
	"bytes"
	"errors"
	"fmt"
	gomultierror "github.com/hashicorp/go-multierror"
	"strconv"
)

var (
	targetResumeFieldMap     = make(map[string]string, 30)
	targetResumeFieldMapType = make(map[string]string, 30)
)

func init() {
	targetResumeFieldMap["id"] = ""
	targetResumeFieldMap["active"] = ""
	targetResumeFieldMap["job_name"] = "index"
	targetResumeFieldMap["salary"] = "filter"
	targetResumeFieldMap["job_desc_achievements"] = "index"
	targetResumeFieldMap["institute_name"] = "index"
	targetResumeFieldMap["customer_id"] = ""
	targetResumeFieldMap["work_type"] = ""
	targetResumeFieldMap["skills"] = "index"
	targetResumeFieldMap["name"] = "index"
	targetResumeFieldMap["business_trip"] = "filter"
	targetResumeFieldMap["default_work_type"] = "filter"
	targetResumeFieldMap["resume_language"] = "filter"
	targetResumeFieldMap["created_at"] = ""
	targetResumeFieldMap["languages"] = "filter"
	targetResumeFieldMap["regular_trip"] = "filter"
	targetResumeFieldMap["metro"] = "filter"
	targetResumeFieldMap["company_name"] = "index"
	targetResumeFieldMap["additional_calc_form"] = "filter"
	targetResumeFieldMap["about_short"] = "index"
	targetResumeFieldMap["specialization"] = "filter"
	targetResumeFieldMap["status"] = ""
	targetResumeFieldMap["job_desc_duties"] = "index"
	targetResumeFieldMap["payment_period"] = "filter"
	targetResumeFieldMap["work_license"] = "filter"
	targetResumeFieldMap["certificate_name"] = "index"
	targetResumeFieldMap["salary_curr"] = "filter"
	targetResumeFieldMap["industries"] = "filter"
	targetResumeFieldMap["city"] = "filter"
	targetResumeFieldMap["updated_at"] = ""
	targetResumeFieldMapType["id"] = "uint32"
	targetResumeFieldMapType["name"] = "string"
	targetResumeFieldMapType["active"] = "bool"
	targetResumeFieldMapType["created_at"] = "int64"
	targetResumeFieldMapType["updated_at"] = "int64"
	targetResumeFieldMapType["job_name"] = "string"
	targetResumeFieldMapType["job_desc_duties"] = "string"
	targetResumeFieldMapType["job_desc_achievements"] = "string"
	targetResumeFieldMapType["company_name"] = "string"
	targetResumeFieldMapType["institute_name"] = "string"
	targetResumeFieldMapType["certificate_name"] = "string"
	targetResumeFieldMapType["customer_id"] = "uint32"
	targetResumeFieldMapType["languages"] = "[]uint32"
	targetResumeFieldMapType["salary_curr"] = "string"
	targetResumeFieldMapType["payment_period"] = "uint32"
	targetResumeFieldMapType["industries"] = "[]uint32"
	targetResumeFieldMapType["business_trip"] = "uint32"
	targetResumeFieldMapType["default_work_type"] = "uint32"
	targetResumeFieldMapType["regular_trip"] = "uint32"
	targetResumeFieldMapType["work_license"] = "[]uint32"
	targetResumeFieldMapType["resume_language"] = "uint32"
	targetResumeFieldMapType["metro"] = "[]uint32"
	targetResumeFieldMapType["work_type"] = "[]uint32"
	targetResumeFieldMapType["additional_calc_form"] = "[]uint32"
	targetResumeFieldMapType["about_short"] = "string"
	targetResumeFieldMapType["salary"] = "uint32"
	targetResumeFieldMapType["skills"] = "string"
	targetResumeFieldMapType["city"] = "uint32"
	targetResumeFieldMapType["specialization"] = "uint32"
	targetResumeFieldMapType["status"] = "uint32"
}
func (re *ResumeSearchEntity) BuildSearchQuery(limit int) (string, error) {
	var (
		resErr error
	)
	if len(re.Query) == 0 {
		return "", errors.New("err validation. empty search req")
	}
	query := re.Query
	sb := bytes.NewBufferString(fmt.Sprintf("SELECT * FROM resumes WHERE MATCH('*%s*')", query))
	for _, v := range re.FilterParams {
		if v.Filter == "" {
			return "", errors.New("err validation. empty filter field")
		}
		fv, ok := targetResumeFieldMap[v.Filter]
		if !ok {
			return "", errors.New("err validation. wrong filter param name")
		}
		if fv != "filter" {
			return "", errors.New("err validation. field can't be used as filter")
		}
		switch v.Value.(type) {
		case *FilterParams_SingleInt:
			ft, ok := targetResumeFieldMapType[v.Filter]
			if !ok {
				return "", errors.New("err validation. can't find filter name")
			}
			if ft != "uint32" {
				return "", errors.New("err validation. mismatch filter value type")
			}
			_, err := sb.WriteString(" AND ")
			_, err = sb.WriteString(v.Filter)
			_, err = sb.WriteString(" = ")
			_, err = sb.WriteString(strconv.FormatInt(int64(v.GetSingleInt()), 10))
			if err != nil {
				resErr = gomultierror.Append(resErr, err)
			}
		case *FilterParams_SingleString:
			ft, ok := targetResumeFieldMapType[v.Filter]
			if !ok {
				return "", errors.New("err validation. can't find filter name")
			}
			if ft != "string" {
				return "", errors.New("err validation. mismatch filter value type")
			}
			_, err := sb.WriteString(" AND ")
			_, err = sb.WriteString(v.Filter)
			_, err = sb.WriteString(" = ")
			_, err = sb.WriteString(v.GetSingleString())
			if err != nil {
				resErr = gomultierror.Append(resErr, err)
			}
		case *FilterParams_IntArray:
			ft, ok := targetResumeFieldMapType[v.Filter]
			if !ok {
				return "", errors.New("err validation. can't find filter name")
			}
			if ft != "[]uint32" {
				return "", errors.New("err validation. mismatch filter value type")
			}
			arr := v.GetIntArray()
			if arr == nil {
				return "", errors.New("err validation. got nil array")
			}
			arrVal := arr.GetValues()
			if len(arrVal) == 0 {
				return "", errors.New("err validation. got empty array")
			}
			var (
				sbp = bytes.NewBufferString("")
			)
			for i, v := range arrVal {
				var err error
				if i == 0 {
					_, err = sbp.WriteString("(")
				}
				_, err = sbp.WriteString(strconv.FormatInt(int64(v), 10))
				if i == len(arrVal)-1 {
					_, err = sbp.WriteString(")")
				} else {
					_, err = sbp.WriteString(",")
				}
				if err != nil {
					resErr = gomultierror.Append(resErr, err)
				}
			}
			_, err := sb.WriteString(" AND ")
			_, err = sb.WriteString(v.Filter)
			_, err = sb.WriteString(" IN")
			_, err = sb.WriteString(sbp.String())
			if err != nil {
				resErr = gomultierror.Append(resErr, err)
			}
		}
	}
	for _, v := range re.SortParams {
		if v.Field == "" {
			return "", errors.New("err validation. empty sort field")
		}
		fv, ok := targetResumeFieldMap[v.Field]
		if !ok {
			return "", errors.New("err validation. wrong sort param name")
		}
		if fv != "" {
			return "", errors.New("err validation. field can't be used as sorted")
		}
		switch v.Order.(type) {
		case *SortParams_ASC:
			_, err := sb.WriteString(" ORDER BY ")
			_, err = sb.WriteString(v.Field)
			_, err = sb.WriteString(" ASC")
			if err != nil {
				resErr = gomultierror.Append(resErr, err)
			}
		case *SortParams_DESC:
			_, err := sb.WriteString(" ORDER BY ")
			_, err = sb.WriteString(v.Field)
			_, err = sb.WriteString(" DESC")
			if err != nil {
				resErr = gomultierror.Append(resErr, err)
			}
		}
	}
	_, err := sb.WriteString(fmt.Sprintf(" LIMIT %d;", limit))
	if err != nil {
		resErr = gomultierror.Append(resErr, err)
	}
	if resErr != nil {
		return "", resErr
	}
	return sb.String(), nil
}
