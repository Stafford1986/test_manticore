// Code generated by generator, DO NOT EDIT.
package pb

import (
	"errors"
	"fmt"
	"strconv"
	"strings"
)

func (re *VacancyEntity) ParseDbResult(m map[string]interface{}) (*VacancyEntity, error) {
	var (
		res = &VacancyEntity{}
	)
	for k, v := range m {
		switch k {
		case "id":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert id")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to Id")
			}
			res.Id = uint32(p)
		case "name":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert name")
			}
			res.Name = string(val)
		case "active":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert active")
			}
			p, err := strconv.Atoi(string(val))
			if err != nil {
				return nil, errors.New("err convert value to Active")
			}
			if p == 0 {
				res.Active = false
			} else {
				res.Active = true
			}
		case "created_at":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert created_at")
			}
			p, err := strconv.ParseInt(string(val), 10, 64)
			if err != nil {
				return nil, errors.New("err convert value to CreatedAt")
			}
			res.CreatedAt = p
		case "updated_at":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert updated_at")
			}
			p, err := strconv.ParseInt(string(val), 10, 64)
			if err != nil {
				return nil, errors.New("err convert value to UpdatedAt")
			}
			res.UpdatedAt = p
		case "skills":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert skills")
			}
			res.Skills = string(val)
		case "city":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert city")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to City")
			}
			res.City = uint32(p)
		case "city_level":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert city_level")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to CityLevel")
			}
			res.CityLevel = uint32(p)
		case "brand":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert brand")
			}
			res.Brand = string(val)
		case "website_url":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert website_url")
			}
			res.WebsiteUrl = string(val)
		case "logo":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert logo")
			}
			res.Logo = string(val)
		case "industry_groups":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert industry_groups")
			}
			var (
				r []uint32
			)
			s := strings.Split(string(val), ",")
			for _, sv := range s {
				p, err := strconv.ParseUint(string(sv), 10, 32)
				if err != nil {
					return nil, errors.New("err convert value to IndustryGroups")
				}
				r = append(r, uint32(p))
			}
			res.IndustryGroups = r
		case "company_id":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert company_id")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to CompanyId")
			}
			res.CompanyId = uint32(p)
		case "specialization":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert specialization")
			}
			var (
				r []uint32
			)
			s := strings.Split(string(val), ",")
			for _, sv := range s {
				p, err := strconv.ParseUint(string(sv), 10, 32)
				if err != nil {
					return nil, errors.New("err convert value to Specialization")
				}
				r = append(r, uint32(p))
			}
			res.Specialization = r
		case "metro":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert metro")
			}
			var (
				r []uint32
			)
			s := strings.Split(string(val), ",")
			for _, sv := range s {
				p, err := strconv.ParseUint(string(sv), 10, 32)
				if err != nil {
					return nil, errors.New("err convert value to Metro")
				}
				r = append(r, uint32(p))
			}
			res.Metro = r
		case "salary_before_tax":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert salary_before_tax")
			}
			p, err := strconv.Atoi(string(val))
			if err != nil {
				return nil, errors.New("err convert value to SalaryBeforeTax")
			}
			if p == 0 {
				res.SalaryBeforeTax = false
			} else {
				res.SalaryBeforeTax = true
			}
		case "salary_curr":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert salary_curr")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to SalaryCurr")
			}
			res.SalaryCurr = uint32(p)
		case "job_responsibility":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert job_responsibility")
			}
			res.JobResponsibility = string(val)
		case "job_requirement":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert job_requirement")
			}
			res.JobRequirement = string(val)
		case "work_condition":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert work_condition")
			}
			res.WorkCondition = string(val)
		case "city_visibility":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert city_visibility")
			}
			var (
				r []uint32
			)
			s := strings.Split(string(val), ",")
			for _, sv := range s {
				p, err := strconv.ParseUint(string(sv), 10, 32)
				if err != nil {
					return nil, errors.New("err convert value to CityVisibility")
				}
				r = append(r, uint32(p))
			}
			res.CityVisibility = r
		case "vacancy_language":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert vacancy_language")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to VacancyLanguage")
			}
			res.VacancyLanguage = uint32(p)
		case "business_trips":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert business_trips")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to BusinessTrips")
			}
			res.BusinessTrips = uint32(p)
		case "self_employed":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert self_employed")
			}
			p, err := strconv.Atoi(string(val))
			if err != nil {
				return nil, errors.New("err convert value to SelfEmployed")
			}
			if p == 0 {
				res.SelfEmployed = false
			} else {
				res.SelfEmployed = true
			}
		case "ip_employed":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert ip_employed")
			}
			p, err := strconv.Atoi(string(val))
			if err != nil {
				return nil, errors.New("err convert value to IpEmployed")
			}
			if p == 0 {
				res.IpEmployed = false
			} else {
				res.IpEmployed = true
			}
		case "payment_period":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert payment_period")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to PaymentPeriod")
			}
			res.PaymentPeriod = uint32(p)
		case "salary_from":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert salary_from")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to SalaryFrom")
			}
			res.SalaryFrom = uint32(p)
		case "salary_to":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert salary_to")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to SalaryTo")
			}
			res.SalaryTo = uint32(p)
		case "default_work_type":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert default_work_type")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to DefaultWorkType")
			}
			res.DefaultWorkType = uint32(p)
		case "work_type":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert work_type")
			}
			var (
				r []uint32
			)
			s := strings.Split(string(val), ",")
			for _, sv := range s {
				p, err := strconv.ParseUint(string(sv), 10, 32)
				if err != nil {
					return nil, errors.New("err convert value to WorkType")
				}
				r = append(r, uint32(p))
			}
			res.WorkType = r
		case "experience":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert experience")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to Experience")
			}
			res.Experience = uint32(p)
		case "min_customer_languages":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert min_customer_languages")
			}
			var (
				r []uint32
			)
			s := strings.Split(string(val), ",")
			for _, sv := range s {
				p, err := strconv.ParseUint(string(sv), 10, 32)
				if err != nil {
					return nil, errors.New("err convert value to MinCustomerLanguages")
				}
				r = append(r, uint32(p))
			}
			res.MinCustomerLanguages = r
		case "driver_license":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert driver_license")
			}
			var (
				r []uint32
			)
			s := strings.Split(string(val), ",")
			for _, sv := range s {
				p, err := strconv.ParseUint(string(sv), 10, 32)
				if err != nil {
					return nil, errors.New("err convert value to DriverLicense")
				}
				r = append(r, uint32(p))
			}
			res.DriverLicense = r
		case "driver_exp":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert driver_exp")
			}
			p, err := strconv.ParseUint(string(val), 10, 32)
			if err != nil {
				return nil, errors.New("err convert value to DriverExp")
			}
			res.DriverExp = uint32(p)
		case "have_car":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert have_car")
			}
			p, err := strconv.Atoi(string(val))
			if err != nil {
				return nil, errors.New("err convert value to HaveCar")
			}
			if p == 0 {
				res.HaveCar = false
			} else {
				res.HaveCar = true
			}
		case "restrictions":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert restrictions")
			}
			var (
				r []uint32
			)
			s := strings.Split(string(val), ",")
			for _, sv := range s {
				p, err := strconv.ParseUint(string(sv), 10, 32)
				if err != nil {
					return nil, errors.New("err convert value to Restrictions")
				}
				r = append(r, uint32(p))
			}
			res.Restrictions = r
		case "list_respond_button":
			val, ok := v.([]byte)
			if !ok {
				return nil, errors.New("err convert list_respond_button")
			}
			p, err := strconv.Atoi(string(val))
			if err != nil {
				return nil, errors.New("err convert value to ListRespondButton")
			}
			if p == 0 {
				res.ListRespondButton = false
			} else {
				res.ListRespondButton = true
			}
		default:
			return nil, fmt.Errorf("unknown field %s", k)
		}
	}
	return res, nil
}
